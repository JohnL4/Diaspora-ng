* Using FireBase (NoSQL database).

** Authentication
   
  Default rules require authentication.  I'm not comfortable leaving the database world-writable, so I figured out how
  to authenticate.

  It's kind of wacky (like all this stuff on the web).  The recommended method is redirect (on mobile, anyway, and I
  didn't want to make two logic paths).  On a redirect, you can wind up throwing away all your state (since you browse
  to a different site and browse back, essentially), so I jammed the cluster xml into localStorage.  (a) You can only
  store strings in localStorage, and (b) localStorage as a web standard seems to have been around long enough for all
  the major browsers to implement it.

  To find out which user is currently logged (if any), you have to set up an event listener for the "auth changed" event
  in Firebase, even when you're first loading the page.  That's how Firebase delivers the initial snapshot of current
  state.

  (The same is true for database reads, by the way.  I wonder how common a paradigm that is.)

** Database

*** Structure

    Don't want to inhale the entire database when first loading the app.  We just need a list of clusters, and then
    details for each cluster.

    Looks like we can't represent arrays directly in NoSQL, so we do it by having multiple children
    at a node.

    #+BEGIN_SRC indented-text
      root:
         users                        
            <user>                    # uid
               name: string
               email: string
               lastLogin: date
         clusters                     # Data whose size is more-or-less bounded -- just simple data items.
            <uniqueClusterName>       # Make unique by appending uid of creating user?
               [lastEditedByUser: uid] # Note that this isn't actually needed, since the UID is part of the uniqueClusterName.
               lastEditedDate: Date
               notes: string
         clusterData                  # "Scalable" data -- unbounded lists, large-ish XML, etc.
            <uniqueClusterName>       # Append uid to make unique.
               xml: xml string        # XML of the cluster
               owners                 # Users who are allowed to change sharing.  Initially, the uid of the creating user.
                  <owner>             # uid
                  (repeated)
               editors                # Users allowed to edit this cluster.  Owners always allowed to edit, so don't need to
                                      # include them in this list.
                  <user>              # uid; Need a special value indicating "all users".
                  (repeated)
               viewers                # Users allowed to see this cluster
                  <user>
                  (repeated)
    #+END_SRC

**** Security

     - Viewers :: Read permissions
     - Editors :: Write permissions, but only to data, not lists of users
     - Owners :: Write permissions, /including/ to lists of users

***** TODO Screen for sharing that lists available users

      Don't disclose UIDs unnecessarily.

      Need to be able to set "world" as share target.
      
***** TODO clusters/clusterData

      Any fool can create (not overwrite).  When they do, they become owners.  (TODO: something
      about =newdata= vs. old data?)

      Anyone can view (read) if they're listed under =clusterData/viewers= (TODO: does this affect
      /listing/ cluster nodes? Answer: listing is allowed if the node corresponding to the list
      (i.e., the parent node of all the children) is readable, regardless of the children's
      individual status.  Conversely, if the parent node is not readable, listing is not allowed,
      even though child nodes may be readable (in which case, those children can be read
      individually. traversing through the parent node in spite of the fact that it cannot be read.)

      Anyone can write if they're listed under =clusterData/editors=.  (Writing new XML will require
      merging on the client, so edits to unaffected starsystems are not lost.)

      =clusterData/owners= can be written to /iff/ user is already present in =owners= list.

      Only owners can delete.

*** Use

    Need to cover two cases:

    - generated, not-yet-persisted cluster (no deep link (i.e., parameterized url) possible)
    - persisted cluster (deep link via url parameterization that causes cluster to be loaded as observable)

**** Generated Cluster

     Make svc.currentCluster observable, UN-hook it from firebase (if hooked).

**** Persisted Cluster

     Make svc.currentCluster observable, hook it up to firebase (UN-hook first).
